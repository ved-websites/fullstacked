input BoolFieldUpdateOperationsInput {
  set: Boolean
}

input BoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

type CreateUserOutput {
  """Email of the created user"""
  email: String!

  """First name of the user"""
  firstName: String

  """Last name of the user"""
  lastName: String

  """Generated registerToken of the created user"""
  registerToken: String!
}

"""
A date-time string at UTC, such as 2019-12-03T09:54:33Z, compliant with the date-time format.
"""
scalar DateTime

input DateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

type ForgotPasswordRequestOutput {
  """Token for password reset attempt"""
  token: String!
}

type GetUserOutput {
  _count: UserCount!
  createdAt: DateTime!
  email: String!
  emailLang: String!
  firstName: String
  id: ID!
  lang: String
  lastName: String
  messages: [Message!]
  online: Boolean!
  passwordResetAttempts: [PasswordResetAttempt!]
  profilePictureRef: String
  registerToken: String
  roles: [Role!]!
  updatedAt: DateTime!
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

type LiveUser {
  _count: UserCount!
  createdAt: DateTime!
  email: String!
  emailLang: String!
  firstName: String
  id: ID!
  lang: String
  lastName: String
  messages: [Message!]
  online: Boolean!
  passwordResetAttempts: [PasswordResetAttempt!]
  profilePictureRef: String
  registerToken: String
  roles: [Role!]
  updatedAt: DateTime!
}

type LoggedUserOutput {
  """Generated accessToken of the user"""
  accessToken: String!
}

input LoginUserInput {
  """Email of the user"""
  email: String!

  """Password of the user"""
  password: String!
}

type Message {
  id: ID!
  text: String!
  time: DateTime!
  user: User!
}

type MessageAvgAggregate {
  id: Float
}

type MessageCountAggregate {
  _all: Int!
  id: Int!
  text: Int!
  time: Int!
}

input MessageCreateManyUserInput {
  id: Int
  text: String!
}

input MessageCreateManyUserInputEnvelope {
  data: [MessageCreateManyUserInput!]!
  skipDuplicates: Boolean
}

input MessageCreateNestedManyWithoutUserInput {
  connect: [MessageWhereUniqueInput!]
  connectOrCreate: [MessageCreateOrConnectWithoutUserInput!]
  create: [MessageCreateWithoutUserInput!]
  createMany: MessageCreateManyUserInputEnvelope
}

input MessageCreateOrConnectWithoutUserInput {
  create: MessageCreateWithoutUserInput!
  where: MessageWhereUniqueInput!
}

input MessageCreateWithoutUserInput {
  text: String!
}

input MessageListRelationFilter {
  every: MessageWhereInput
  none: MessageWhereInput
  some: MessageWhereInput
}

type MessageMaxAggregate {
  id: Int
  text: String
  time: DateTime
}

type MessageMinAggregate {
  id: Int
  text: String
  time: DateTime
}

input MessageScalarWhereInput {
  AND: [MessageScalarWhereInput!]
  NOT: [MessageScalarWhereInput!]
  OR: [MessageScalarWhereInput!]
  id: IntFilter
  text: StringFilter
}

type MessageSumAggregate {
  id: Int
}

input MessageUpdateManyMutationInput {
  text: StringFieldUpdateOperationsInput
}

input MessageUpdateManyWithWhereWithoutUserInput {
  data: MessageUpdateManyMutationInput!
  where: MessageScalarWhereInput!
}

input MessageUpdateManyWithoutUserNestedInput {
  connect: [MessageWhereUniqueInput!]
  connectOrCreate: [MessageCreateOrConnectWithoutUserInput!]
  create: [MessageCreateWithoutUserInput!]
  createMany: MessageCreateManyUserInputEnvelope
  delete: [MessageWhereUniqueInput!]
  deleteMany: [MessageScalarWhereInput!]
  disconnect: [MessageWhereUniqueInput!]
  set: [MessageWhereUniqueInput!]
  update: [MessageUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [MessageUpdateManyWithWhereWithoutUserInput!]
  upsert: [MessageUpsertWithWhereUniqueWithoutUserInput!]
}

input MessageUpdateWithWhereUniqueWithoutUserInput {
  data: MessageUpdateWithoutUserInput!
  where: MessageWhereUniqueInput!
}

input MessageUpdateWithoutUserInput {
  text: StringFieldUpdateOperationsInput
}

input MessageUpsertWithWhereUniqueWithoutUserInput {
  create: MessageCreateWithoutUserInput!
  update: MessageUpdateWithoutUserInput!
  where: MessageWhereUniqueInput!
}

input MessageWhereInput {
  AND: [MessageWhereInput!]
  NOT: [MessageWhereInput!]
  OR: [MessageWhereInput!]
  id: IntFilter
  text: StringFilter
  user: UserRelationFilter
}

input MessageWhereUniqueInput {
  id: Int
}

type Mutation {
  addMessage(data: MessageCreateWithoutUserInput!): Message
  createUser(data: UserCreateInput!): CreateUserOutput!
  deleteProfilePicture: Boolean!
  deleteUser(where: UserWhereUniqueInput!): GetUserOutput
  editSelfPassword(password: String!): Boolean
  editUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User!
  editUserProfile(data: UserUpdateInput!): User!
  forgotPasswordRequest(email: String!): ForgotPasswordRequestOutput!
  login(data: LoginUserInput!): LoggedUserOutput!
  logout: Boolean!
  register(data: RegisterInput!): Session!
  renewSession: RenewedSessionOutput
  resendNewUserEmail(where: UserWhereUniqueInput!): Boolean!
  resetPassword(data: ResetPasswordInput!): Boolean!
  updateMessage(query: MessageUpdateWithWhereUniqueWithoutUserInput!): Message!
  uploadProfilePicture(profilePicture: Upload!): UploadProfilePictureOutput!
}

input NestedBoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input NestedDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input NullableStringFieldUpdateOperationsInput {
  set: String
}

type PasswordResetAttempt {
  expiryDate: DateTime!
  id: ID!
  token: String!
  used: Boolean!
  user: User!
  userId: String!
}

input PasswordResetAttemptCreateManyUserInput {
  expiryDate: DateTime!
  id: Int
  token: String!
  used: Boolean
}

input PasswordResetAttemptCreateManyUserInputEnvelope {
  data: [PasswordResetAttemptCreateManyUserInput!]!
  skipDuplicates: Boolean
}

input PasswordResetAttemptCreateNestedManyWithoutUserInput {
  connect: [PasswordResetAttemptWhereUniqueInput!]
  connectOrCreate: [PasswordResetAttemptCreateOrConnectWithoutUserInput!]
  create: [PasswordResetAttemptCreateWithoutUserInput!]
  createMany: PasswordResetAttemptCreateManyUserInputEnvelope
}

input PasswordResetAttemptCreateOrConnectWithoutUserInput {
  create: PasswordResetAttemptCreateWithoutUserInput!
  where: PasswordResetAttemptWhereUniqueInput!
}

input PasswordResetAttemptCreateWithoutUserInput {
  expiryDate: DateTime!
  token: String!
  used: Boolean
}

input PasswordResetAttemptListRelationFilter {
  every: PasswordResetAttemptWhereInput
  none: PasswordResetAttemptWhereInput
  some: PasswordResetAttemptWhereInput
}

input PasswordResetAttemptScalarWhereInput {
  AND: [PasswordResetAttemptScalarWhereInput!]
  NOT: [PasswordResetAttemptScalarWhereInput!]
  OR: [PasswordResetAttemptScalarWhereInput!]
  expiryDate: DateTimeFilter
  id: IntFilter
  token: StringFilter
  used: BoolFilter
  userId: StringFilter
}

input PasswordResetAttemptUpdateManyMutationInput {
  expiryDate: DateTimeFieldUpdateOperationsInput
  token: StringFieldUpdateOperationsInput
  used: BoolFieldUpdateOperationsInput
}

input PasswordResetAttemptUpdateManyWithWhereWithoutUserInput {
  data: PasswordResetAttemptUpdateManyMutationInput!
  where: PasswordResetAttemptScalarWhereInput!
}

input PasswordResetAttemptUpdateManyWithoutUserNestedInput {
  connect: [PasswordResetAttemptWhereUniqueInput!]
  connectOrCreate: [PasswordResetAttemptCreateOrConnectWithoutUserInput!]
  create: [PasswordResetAttemptCreateWithoutUserInput!]
  createMany: PasswordResetAttemptCreateManyUserInputEnvelope
  delete: [PasswordResetAttemptWhereUniqueInput!]
  deleteMany: [PasswordResetAttemptScalarWhereInput!]
  disconnect: [PasswordResetAttemptWhereUniqueInput!]
  set: [PasswordResetAttemptWhereUniqueInput!]
  update: [PasswordResetAttemptUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [PasswordResetAttemptUpdateManyWithWhereWithoutUserInput!]
  upsert: [PasswordResetAttemptUpsertWithWhereUniqueWithoutUserInput!]
}

input PasswordResetAttemptUpdateWithWhereUniqueWithoutUserInput {
  data: PasswordResetAttemptUpdateWithoutUserInput!
  where: PasswordResetAttemptWhereUniqueInput!
}

input PasswordResetAttemptUpdateWithoutUserInput {
  expiryDate: DateTimeFieldUpdateOperationsInput
  token: StringFieldUpdateOperationsInput
  used: BoolFieldUpdateOperationsInput
}

input PasswordResetAttemptUpsertWithWhereUniqueWithoutUserInput {
  create: PasswordResetAttemptCreateWithoutUserInput!
  update: PasswordResetAttemptUpdateWithoutUserInput!
  where: PasswordResetAttemptWhereUniqueInput!
}

input PasswordResetAttemptWhereInput {
  AND: [PasswordResetAttemptWhereInput!]
  NOT: [PasswordResetAttemptWhereInput!]
  OR: [PasswordResetAttemptWhereInput!]
  expiryDate: DateTimeFilter
  id: IntFilter
  token: StringFilter
  used: BoolFilter
  user: UserRelationFilter
  userId: StringFilter
}

input PasswordResetAttemptWhereUniqueInput {
  id: Int
}

type Query {
  getRoles(where: RoleWhereInput): [Role!]!
  getSessionUser: LiveUser
  getUnregisteredUser(registerToken: String!): UnregisteredUserOutput!
  getUser(where: UserWhereUniqueInput!): GetUserOutput
  getUsers(where: UserWhereInput): [LiveUser!]!
  messages(where: MessageWhereInput): [Message!]!
  verifyPasswordResetAttempt(token: String!): User
}

enum QueryMode {
  default
  insensitive
}

input RegisterInput {
  """First name of the user"""
  firstName: String

  """Last Name of the user"""
  lastName: String

  """Password of the user"""
  password: String!

  """The register token provided in the registration link."""
  registerToken: String!
}

type RenewedSessionOutput {
  """Regenerated accessToken of the user"""
  accessToken: String!
}

input ResetPasswordInput {
  """Password of the user"""
  password: String!

  """The token provided to reset the password"""
  token: String!
}

type Role {
  _count: RoleCount!
  createdAt: DateTime!
  id: ID!
  text: String!
  users: [User!]
}

type RoleAvgAggregate {
  id: Float
}

type RoleCount {
  users: Int!
}

type RoleCountAggregate {
  _all: Int!
  createdAt: Int!
  id: Int!
  text: Int!
}

input RoleCreateNestedManyWithoutUsersInput {
  connect: [RoleWhereUniqueInput!]
  connectOrCreate: [RoleCreateOrConnectWithoutUsersInput!]
  create: [RoleCreateWithoutUsersInput!]
}

input RoleCreateOrConnectWithoutUsersInput {
  create: RoleCreateWithoutUsersInput!
  where: RoleWhereUniqueInput!
}

input RoleCreateWithoutUsersInput {
  text: String!
}

input RoleListRelationFilter {
  every: RoleWhereInput
  none: RoleWhereInput
  some: RoleWhereInput
}

type RoleMaxAggregate {
  createdAt: DateTime
  id: Int
  text: String
}

type RoleMinAggregate {
  createdAt: DateTime
  id: Int
  text: String
}

input RoleScalarWhereInput {
  AND: [RoleScalarWhereInput!]
  NOT: [RoleScalarWhereInput!]
  OR: [RoleScalarWhereInput!]
  id: IntFilter
  text: StringFilter
}

type RoleSumAggregate {
  id: Int
}

input RoleUpdateManyMutationInput {
  text: StringFieldUpdateOperationsInput
}

input RoleUpdateManyWithWhereWithoutUsersInput {
  data: RoleUpdateManyMutationInput!
  where: RoleScalarWhereInput!
}

input RoleUpdateManyWithoutUsersNestedInput {
  connect: [RoleWhereUniqueInput!]
  connectOrCreate: [RoleCreateOrConnectWithoutUsersInput!]
  create: [RoleCreateWithoutUsersInput!]
  delete: [RoleWhereUniqueInput!]
  deleteMany: [RoleScalarWhereInput!]
  disconnect: [RoleWhereUniqueInput!]
  set: [RoleWhereUniqueInput!]
  update: [RoleUpdateWithWhereUniqueWithoutUsersInput!]
  updateMany: [RoleUpdateManyWithWhereWithoutUsersInput!]
  upsert: [RoleUpsertWithWhereUniqueWithoutUsersInput!]
}

input RoleUpdateWithWhereUniqueWithoutUsersInput {
  data: RoleUpdateWithoutUsersInput!
  where: RoleWhereUniqueInput!
}

input RoleUpdateWithoutUsersInput {
  text: StringFieldUpdateOperationsInput
}

input RoleUpsertWithWhereUniqueWithoutUsersInput {
  create: RoleCreateWithoutUsersInput!
  update: RoleUpdateWithoutUsersInput!
  where: RoleWhereUniqueInput!
}

input RoleWhereInput {
  AND: [RoleWhereInput!]
  NOT: [RoleWhereInput!]
  OR: [RoleWhereInput!]
  id: IntFilter
  text: StringFilter
  users: UserListRelationFilter
}

input RoleWhereUniqueInput {
  id: Int
  text: String
}

type Session {
  active_expires: String!
  id: ID!
  idle_expires: String!
  user: User!
  user_id: String!
}

type SessionAvgAggregate {
  active_expires: Float
  idle_expires: Float
}

type SessionCountAggregate {
  _all: Int!
  active_expires: Int!
  id: Int!
  idle_expires: Int!
  user_id: Int!
}

type SessionMaxAggregate {
  active_expires: String
  id: String
  idle_expires: String
  user_id: String
}

type SessionMinAggregate {
  active_expires: String
  id: String
  idle_expires: String
  user_id: String
}

type SessionSumAggregate {
  active_expires: String
  idle_expires: String
}

input StringFieldUpdateOperationsInput {
  set: String
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

type Subscription {
  messageAdded(where: MessageWhereInput): Message!
  userEdited(where: UserWhereUniqueInput!): LiveUser!
}

type UnregisteredUserOutput {
  """Email of the unregistered user"""
  email: String!

  """First name of the unregistered user"""
  firstName: String

  """Last name of the unregistered user"""
  lastName: String
}

"""The `Upload` scalar type represents a file upload."""
scalar Upload

type UploadProfilePictureOutput {
  """file name of the uploaded profile picture"""
  fileName: String!
}

type User {
  _count: UserCount!
  createdAt: DateTime!
  email: String!
  emailLang: String!
  firstName: String
  id: ID!
  lang: String
  lastName: String
  messages: [Message!]
  passwordResetAttempts: [PasswordResetAttempt!]
  profilePictureRef: String
  registerToken: String
  roles: [Role!]
  updatedAt: DateTime!
}

type UserCount {
  auth_key: Int!
  auth_session: Int!
  messages: Int!
  passwordResetAttempts: Int!
  roles: Int!
}

type UserCountAggregate {
  _all: Int!
  createdAt: Int!
  email: Int!
  emailLang: Int!
  firstName: Int!
  id: Int!
  lang: Int!
  lastName: Int!
  profilePictureRef: Int!
  registerToken: Int!
  updatedAt: Int!
}

input UserCreateInput {
  email: String!
  emailLang: String!
  firstName: String
  lang: String
  lastName: String
  messages: MessageCreateNestedManyWithoutUserInput
  passwordResetAttempts: PasswordResetAttemptCreateNestedManyWithoutUserInput
  profilePictureRef: String
  registerToken: String
  roles: RoleCreateNestedManyWithoutUsersInput
}

input UserListRelationFilter {
  every: UserWhereInput
  none: UserWhereInput
  some: UserWhereInput
}

type UserMaxAggregate {
  createdAt: DateTime
  email: String
  emailLang: String
  firstName: String
  id: String
  lang: String
  lastName: String
  profilePictureRef: String
  registerToken: String
  updatedAt: DateTime
}

type UserMinAggregate {
  createdAt: DateTime
  email: String
  emailLang: String
  firstName: String
  id: String
  lang: String
  lastName: String
  profilePictureRef: String
  registerToken: String
  updatedAt: DateTime
}

input UserRelationFilter {
  is: UserWhereInput
  isNot: UserWhereInput
}

input UserUpdateInput {
  email: StringFieldUpdateOperationsInput
  emailLang: StringFieldUpdateOperationsInput
  firstName: NullableStringFieldUpdateOperationsInput
  lang: NullableStringFieldUpdateOperationsInput
  lastName: NullableStringFieldUpdateOperationsInput
  messages: MessageUpdateManyWithoutUserNestedInput
  passwordResetAttempts: PasswordResetAttemptUpdateManyWithoutUserNestedInput
  profilePictureRef: NullableStringFieldUpdateOperationsInput
  registerToken: NullableStringFieldUpdateOperationsInput
  roles: RoleUpdateManyWithoutUsersNestedInput
}

input UserWhereInput {
  AND: [UserWhereInput!]
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  email: StringFilter
  emailLang: StringFilter
  firstName: StringNullableFilter
  lang: StringNullableFilter
  lastName: StringNullableFilter
  messages: MessageListRelationFilter
  passwordResetAttempts: PasswordResetAttemptListRelationFilter
  profilePictureRef: StringNullableFilter
  registerToken: StringNullableFilter
  roles: RoleListRelationFilter
}

input UserWhereUniqueInput {
  email: String
  registerToken: String
}
